<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: util.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: util.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const fs = require('fs')
const path = require('path')
const crypto = require('crypto')
const FormData = require('form-data')

const { ERRORS } = require('./consts')
/**
 * @typedef {object} Util
 * @property {function} getFormData - Method for getting form data from formFields and files
 * @property {function} readFile - Method for reading files
 * @property {function} verifyResponse - Method for verifying responses
 */

/**
 * Celsius js SDK Util
 * @module celsius-js-sdk/util
 */

/**
 * Creates and configures Util
 *
 * @function
 *
 * @param {object} config - Contains configuration data
 * @returns {Util}
 */
const Util = function (config) {
  const Util = this
  Util.config = config

  return {
    /**
     * Creates and returns form data from provided form fields and files
     *
     * @function
     *
     * @param {object} formFields - Object containing form fields
     * @param {object} files - Object containing files. Keys are field names, values are paths
     * @returns {Promise} FormData that is to be sent with a request
     */
    getFormData: function (formFields, files) {
      return new Promise((resolve, reject) => {
        const formData = new FormData({ maxDataSize: 10485760 })

        for (const key in formFields) {
          if (formFields.hasOwnProperty(key)) {
            formData.append(key, formFields[key])
          }
        }

        const promises = []
        const fileMetadata = []

        for (const key in files) {
          if (files.hasOwnProperty(key)) {
            const filePath = files[key]
            fileMetadata.push({
              name: path.basename(filePath),
              fieldName: key
            })
            promises.push(this.readFile(filePath))
          }
        }

        Promise.all(promises).then((results) => {
          for (let i = 0; i &lt; results.length; i++) {
            const metadata = fileMetadata[i]
            formData.append(metadata.fieldName, results[i], {
              filename: metadata.name
            })
          }
          resolve(formData)
        })
      })
    },

    /**
     * Reads a file asynchronously.
     *
     * @function readFile
     *
     * @param {string} filePath - Path to the file
     * @returns {Promise} Contents of a file stored in a buffer
     */
    readFile: function (filePath) {
      return new Promise((resolve, reject) => {
        const stream = fs.createReadStream(filePath)

        const chunks = []

        stream.on('data', function (chunk) {
          chunks.push(chunk)
        })

        stream.on('end', function () {
          return resolve(Buffer.concat(chunks))
        })
      })
    },

    /**
     * Verifies responses received from api.
     *
     * @function verifyResponse
     *
     * @param {object} data - Response data
     * @param {string} signature - Header containing signature
     * @returns {boolean} Result of verification
     */
    verifyResponse: function (data, signature) {
      let publicKey = Util.config.publicKey
      if (!publicKey) {
        throw new Error(ERRORS.NO_PUBLIC_KEY)
      }
      publicKey = Buffer.from(publicKey, 'base64').toString()
      return crypto.createVerify('sha256').update(JSON.stringify(data)).verify(publicKey, signature, 'base64')
    }
  }
}

class ValidationError {
  constructor (error) {
    this.status = error.status

    if (error.data.message) {
      this.message = error.data.message
    } else {
      this.message = error.data
    }
  }
}

module.exports = {
  Util,
  ValidationError
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-celsius-js-sdk_core.html">celsius-js-sdk/core</a></li><li><a href="module-celsius-js-sdk_http-client.html">celsius-js-sdk/http-client</a></li><li><a href="module-celsius-js-sdk_util.html">celsius-js-sdk/util</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AUTH_METHODS">AUTH_METHODS</a></li><li><a href="global.html#CONFIG">CONFIG</a></li><li><a href="global.html#ENVIRONMENT">ENVIRONMENT</a></li><li><a href="global.html#PATHS">PATHS</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Mar 12 2019 12:18:00 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
